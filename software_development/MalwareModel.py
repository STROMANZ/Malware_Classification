from PIL import Image
import tensorflow as tf
from keras.models import Sequential
from keras.models import load_model
from keras.layers import Reshape, Conv2D, MaxPooling2D, Flatten, Dense, Dropout
import time
import os
import numpy as np

class Classifier (object) :

    def __init__(self , number_of_classes):

        dropout_rate = 0.3
        self.__DIMEN = 32

        input_shape = (self.__DIMEN**2,)
        print(input_shape)
        convolution_shape = (self.__DIMEN , self.__DIMEN, 1 )
        #kernel_size = (3, 3)
        pool_size = (2, 2)
        strides = 1

#        activation_func = 'tanh'
#        activation_func = 'sigmoid'
#        activation_func = 'hard_sigmoid'
        activation_func = 'relu'
#        activation_func = 'elu'
#        activation_func = 'linear'

        self.__NEURAL_SCHEMA = [

            Reshape(input_shape=input_shape , target_shape=convolution_shape),

            Conv2D(32, kernel_size=(4, 4), strides=strides, activation=activation_func),
            MaxPooling2D(pool_size=pool_size, strides=strides),

            Conv2D(64, kernel_size=(3, 3), strides=strides, activation=activation_func),
            MaxPooling2D(pool_size=pool_size, strides=strides),

            Flatten(),

#            Dense(100, activation=activation_func),
#            Dense(100, activation='sigmoid'),
            Dense(100, activation='hard_sigmoid'),
            Dropout(dropout_rate),

            Dense(number_of_classes, activation='softmax')

        ]

        self.__model = Sequential( self.__NEURAL_SCHEMA )
        self.__model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
        self.__model.summary()

    def fit(self, X, Y  , hyperparameters):
        initial_time = time.time()
        self.__model.fit(X, Y,
                         batch_size=hyperparameters['batch_size'],
                         epochs=hyperparameters['epochs'],
                         callbacks=hyperparameters['callbacks'],
                         validation_data=hyperparameters['val_data']
                         )
        final_time = time.time()
        eta = (final_time - initial_time)
        time_unit = 'seconds'
        if eta >= 60:
            eta = eta / 60
            time_unit = 'minutes'
        self.__model.summary()
        print('Elapsed time acquired for {} epoch(s) -> {} {}'.format(hyperparameters['epochs'], eta, time_unit))

    def evaluate(self , test_X , test_Y  ) :
        return self.__model.evaluate(test_X, test_Y)

    def predict(self, X  ):
        predictions = self.__model.predict( X  )
        return predictions

    def save_model(self , file_path ):
        self.__model.save(file_path )

    def load_model(self , file_path ):
        self.__model = load_model(file_path)
